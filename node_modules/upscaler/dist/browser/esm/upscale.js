import { tf, } from './dependencies.generated';
import { checkValidEnvironment, getImageAsTensor, tensorAsBase64, } from './image.generated';
import { wrapGenerator, warn, isProgress, isMultiArgTensorProgress, processAndDisposeOfTensor, isSingleArgProgress, scaleIncomingPixels, padInput, trimInput, getInputShape, scaleOutput, } from './utils';
import { isTensor, isThreeDimensionalTensor, isFourDimensionalTensor, } from '@upscalerjs/core';
import { makeTick, } from './makeTick';
const WARNING_UNDEFINED_PADDING_URL = 'https://upscalerjs.com/documentation/troubleshooting#padding-is-undefined';
export const WARNING_UNDEFINED_PADDING = [
    '"padding" is undefined, but "patchSize" is explicitly defined.',
    'Without padding, patches of images often have visible artifacting at the seams. Defining an explicit padding will resolve the artifacting.',
    `For more information, see ${WARNING_UNDEFINED_PADDING_URL}.`,
    'To hide this warning, pass an explicit padding of "0".',
].join('\n');
const WARNING_PROGRESS_WITHOUT_PATCH_SIZE_URL = 'https://upscalerjs.com/documentation/troubleshooting#progress-specified-without-patch-size';
export const WARNING_PROGRESS_WITHOUT_PATCH_SIZE = [
    'The "progress" callback was provided but "patchSize" was not defined.',
    'Without a "patchSize", the "progress" callback will never be called.',
    `For more information, see ${WARNING_PROGRESS_WITHOUT_PATCH_SIZE_URL}.`,
].join('\n');
const ERROR_INVALID_TENSOR_PREDICTED_URL = 'https://upscalerjs.com/documentation/troubleshooting#invalid-predicted-tensor';
export const ERROR_INVALID_TENSOR_PREDICTED = (tensor) => [
    `The tensor returned by the model was not a valid rank-4 tensor. It's shape is ${JSON.stringify(tensor.shape)}.}`,
    'UpscalerJS only supports models returning valid image-like data in four dimensional form.',
    `For more information, see ${ERROR_INVALID_TENSOR_PREDICTED_URL}.`,
].join('\n');
const ERROR_INVALID_MODEL_PREDICTION_URL = 'https://upscalerjs.com/documentation/troubleshooting#invalid-model-prediction';
export const ERROR_INVALID_MODEL_PREDICTION = [
    'The model output was not a valid tensor. UpscalerJS only supports models returning valid tensors.',
    'This is likely an error with the model itself, not UpscalerJS.',
    `For more information, see ${ERROR_INVALID_MODEL_PREDICTION_URL}.`,
].join('\n');
export const GET_INVALID_SHAPED_TENSOR = (tensor) => new Error(`Invalid shape provided to getWidthAndHeight, expected tensor of rank 3 or 4: ${JSON.stringify(tensor.shape)}`);
export const GET_UNDEFINED_TENSORS_ERROR = () => new Error('No defined tensors were passed to concatTensors');
export const getWidthAndHeight = (tensor) => {
    if (isFourDimensionalTensor(tensor)) {
        return [tensor.shape[1], tensor.shape[2],];
    }
    if (isThreeDimensionalTensor(tensor)) {
        return [tensor.shape[0], tensor.shape[1],];
    }
    throw GET_INVALID_SHAPED_TENSOR(tensor);
};
export const getRowsAndColumns = (pixels, patchSize) => {
    const [height, width,] = getWidthAndHeight(pixels);
    return {
        rows: Math.ceil(height / patchSize),
        columns: Math.ceil(width / patchSize),
    };
};
const checkAndAdjustStartingPosition = (dimension, origin, sliceOrigin) => {
    if (origin[dimension] < 0) {
        const amount = 0 - origin[dimension];
        origin[dimension] += amount;
        sliceOrigin[dimension] -= amount;
    }
};
const checkAndAdjustEndingPosition = (size, dimension, endPosition, origin, sliceOrigin, sliceEndPosition) => {
    if (endPosition[dimension] > size) {
        const amount = endPosition[dimension] - size;
        let compensatingAmount = 0;
        if (origin[dimension] - amount < 0) {
            compensatingAmount = 0 - (origin[dimension] - amount);
        }
        origin[dimension] -= amount - compensatingAmount;
        endPosition[dimension] -= amount;
        const sliceAmount = amount - compensatingAmount;
        sliceOrigin[dimension] += sliceAmount;
        sliceEndPosition[dimension] += sliceAmount;
    }
};
const checkAndAdjustSliceSize = (dimension, size, sliceEndPosition) => {
    if (sliceEndPosition[dimension] > size[dimension]) {
        sliceEndPosition[dimension] = size[dimension];
    }
};
export const GET_TENSOR_DIMENSION_ERROR_ROW_IS_UNDEFINED = new Error('Row is undefined');
export const GET_TENSOR_DIMENSION_ERROR_COL_IS_UNDEFINED = new Error('Column is undefined');
export const GET_TENSOR_DIMENSION_ERROR_PATCH_SIZE_IS_UNDEFINED = new Error('Patch Size is undefined');
export const GET_TENSOR_DIMENSION_ERROR_HEIGHT_IS_UNDEFINED = new Error('Height is undefined');
export const GET_TENSOR_DIMENSION_ERROR_WIDTH_IS_UNDEFINED = new Error('Width is undefined');
export const getTensorDimensions = ({ row, col, patchSize, height, width, padding = 0, }) => {
    if (row === undefined) {
        throw GET_TENSOR_DIMENSION_ERROR_ROW_IS_UNDEFINED;
    }
    if (col === undefined) {
        throw GET_TENSOR_DIMENSION_ERROR_COL_IS_UNDEFINED;
    }
    if (patchSize === undefined) {
        throw GET_TENSOR_DIMENSION_ERROR_PATCH_SIZE_IS_UNDEFINED;
    }
    if (height === undefined) {
        throw GET_TENSOR_DIMENSION_ERROR_HEIGHT_IS_UNDEFINED;
    }
    if (width === undefined) {
        throw GET_TENSOR_DIMENSION_ERROR_WIDTH_IS_UNDEFINED;
    }
    let yPatchSize = patchSize;
    let xPatchSize = patchSize;
    if (yPatchSize > height) {
        yPatchSize = height;
    }
    if (xPatchSize > width) {
        xPatchSize = width;
    }
    const origin = [
        row * patchSize - padding,
        col * patchSize - padding,
    ];
    const sliceOrigin = [padding, padding,];
    checkAndAdjustStartingPosition(0, origin, sliceOrigin);
    checkAndAdjustStartingPosition(1, origin, sliceOrigin);
    const endPosition = [
        origin[0] + yPatchSize + padding * 2,
        origin[1] + xPatchSize + padding * 2,
    ];
    const sliceEndPosition = [
        sliceOrigin[0] + yPatchSize,
        sliceOrigin[1] + xPatchSize,
    ];
    checkAndAdjustEndingPosition(height, 0, endPosition, origin, sliceOrigin, sliceEndPosition);
    checkAndAdjustEndingPosition(width, 1, endPosition, origin, sliceOrigin, sliceEndPosition);
    const size = [
        endPosition[0] - origin[0],
        endPosition[1] - origin[1],
    ];
    checkAndAdjustSliceSize(0, size, sliceEndPosition);
    checkAndAdjustSliceSize(1, size, sliceEndPosition);
    const sliceSize = [
        sliceEndPosition[0] - sliceOrigin[0],
        sliceEndPosition[1] - sliceOrigin[1],
    ];
    return {
        origin,
        sliceOrigin,
        size,
        sliceSize,
    };
};
export function concatTensors(tensors, axis = 0) {
    const definedTensors = [];
    for (let i = 0; i < tensors.length; i++) {
        const tensor = tensors[i];
        if (tensor !== undefined) {
            definedTensors.push(tensor);
        }
    }
    if (definedTensors.length === 0) {
        throw GET_UNDEFINED_TENSORS_ERROR();
    }
    const concatenatedTensor = tf.concat(definedTensors, axis);
    tensors.forEach(tensor => tensor?.dispose());
    return concatenatedTensor;
}
export const getPercentageComplete = (row, col, columns, total) => {
    const index = row * columns + col + 1;
    const percent = index / total;
    return percent;
};
export const executeModel = (model, pixels) => {
    const predictedPixels = model.predict(pixels);
    if (!isTensor(predictedPixels)) {
        throw new Error(ERROR_INVALID_MODEL_PREDICTION);
    }
    if (isFourDimensionalTensor(predictedPixels)) {
        return predictedPixels;
    }
    throw new Error(ERROR_INVALID_TENSOR_PREDICTED(predictedPixels));
};
export async function* predict(pixels, { output, progress, patchSize: patchSize, padding, progressOutput, }, { model, modelDefinition, }, { imageSize, inputSize, }) {
    const scale = modelDefinition.scale || 1;
    if (inputSize === undefined && patchSize && padding === undefined) {
        warn(WARNING_UNDEFINED_PADDING);
    }
    if (patchSize) {
        const [height, width,] = pixels.shape.slice(1);
        const { rows, columns, } = getRowsAndColumns(pixels, patchSize);
        yield;
        let upscaledTensor;
        const total = rows * columns;
        for (let row = 0; row < rows; row++) {
            let colTensor;
            yield [colTensor, upscaledTensor,];
            for (let col = 0; col < columns; col++) {
                const { origin, size, sliceOrigin, sliceSize, } = getTensorDimensions({
                    row,
                    col,
                    patchSize,
                    padding,
                    height,
                    width,
                });
                yield [upscaledTensor, colTensor,];
                const slicedPixels = pixels.slice([0, origin[0], origin[1],], [-1, size[0], size[1],]);
                yield [upscaledTensor, colTensor, slicedPixels,];
                const prediction = executeModel(model, slicedPixels);
                slicedPixels.dispose();
                yield [upscaledTensor, colTensor, prediction,];
                const startSlice = [0, sliceOrigin[0] * scale, sliceOrigin[1] * scale,];
                const endSlice = [-1, sliceSize[0] * scale, sliceSize[1] * scale,];
                const slicedPrediction = prediction.slice(startSlice, endSlice);
                prediction.dispose();
                yield [upscaledTensor, colTensor, slicedPrediction,];
                const processedPrediction = processAndDisposeOfTensor(slicedPrediction, modelDefinition.postprocess, scaleOutput(modelDefinition.outputRange));
                yield [upscaledTensor, colTensor, processedPrediction,];
                if (progress !== undefined && isProgress(progress)) {
                    const percent = getPercentageComplete(row, col, columns, total);
                    if (isSingleArgProgress(progress)) {
                        progress(percent);
                    }
                    else {
                        const squeezedTensor = processedPrediction.squeeze();
                        if (isMultiArgTensorProgress(progress, output, progressOutput)) {
                            progress(percent, squeezedTensor, row, col);
                        }
                        else {
                            const src = tensorAsBase64(squeezedTensor);
                            squeezedTensor.dispose();
                            progress(percent, src, row, col);
                        }
                    }
                }
                yield [upscaledTensor, colTensor, processedPrediction,];
                colTensor = concatTensors([colTensor, processedPrediction,], 2);
                processedPrediction.dispose();
                yield [upscaledTensor, colTensor,];
            }
            upscaledTensor = concatTensors([upscaledTensor, colTensor,], 1);
            colTensor.dispose();
            yield [upscaledTensor,];
        }
        const processedUpscaledTensor = processAndDisposeOfTensor(upscaledTensor.clone(), trimInput(imageSize, scale));
        upscaledTensor?.dispose();
        yield [processedUpscaledTensor,];
        const squeezedTensor = processedUpscaledTensor.squeeze();
        processedUpscaledTensor.dispose();
        return squeezedTensor;
    }
    if (progress) {
        warn(WARNING_PROGRESS_WITHOUT_PATCH_SIZE);
    }
    const prediction = model.predict(pixels);
    yield [prediction,];
    const postprocessedTensor = processAndDisposeOfTensor(prediction.clone(), modelDefinition.postprocess, scaleOutput(modelDefinition.outputRange), trimInput(imageSize, scale));
    prediction.dispose();
    yield [postprocessedTensor,];
    const squeezedTensor = postprocessedTensor.squeeze();
    postprocessedTensor.dispose();
    return squeezedTensor;
}
export const getCopyOfInput = (input) => (isTensor(input) ? input.clone() : input);
export async function* upscale(input, args, { model, modelDefinition, }) {
    const parsedInput = getCopyOfInput(input);
    const startingPixels = await getImageAsTensor(parsedInput);
    yield startingPixels;
    const imageSize = startingPixels.shape;
    const inputSize = getInputShape(model);
    const preprocessedPixels = processAndDisposeOfTensor(startingPixels, modelDefinition.preprocess, scaleIncomingPixels(modelDefinition.inputRange), padInput(inputSize));
    yield preprocessedPixels;
    const gen = predict(preprocessedPixels, args, {
        model,
        modelDefinition,
    }, {
        imageSize,
        inputSize,
    });
    let result = await gen.next();
    yield result.value;
    while (!result.done) {
        result = await gen.next();
        if (Array.isArray(result.value)) {
            yield [...result.value, preprocessedPixels,];
        }
        else if (isTensor(result.value)) {
            yield [result.value, preprocessedPixels,];
        }
        else {
            yield preprocessedPixels;
        }
    }
    preprocessedPixels.dispose();
    const upscaledPixels = result.value;
    if (args.output === 'tensor') {
        return upscaledPixels;
    }
    const base64Src = tensorAsBase64(upscaledPixels);
    upscaledPixels.dispose();
    return base64Src;
}
export async function cancellableUpscale(input, { signal, awaitNextFrame, ...args }, internalArgs) {
    checkValidEnvironment(input, {
        output: args.output,
        progressOutput: args.progressOutput,
    });
    const tick = makeTick(signal || internalArgs.signal, awaitNextFrame);
    await tick();
    const upscaledPixels = await wrapGenerator(upscale(input, args, internalArgs), tick);
    await tick();
    return upscaledPixels;
}
