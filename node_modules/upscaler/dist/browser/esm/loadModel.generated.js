import { ModelDefinitionValidationError, } from '@upscalerjs/core';
import { ERROR_MODEL_DEFINITION_BUG, getModelDefinitionError, loadTfModel, } from './utils';
import { isValidModelDefinition, } from '@upscalerjs/core';
export const CDN_PATH_DEFINITIONS = {
    'jsdelivr': (packageName, version, path) => `https://cdn.jsdelivr.net/npm/${packageName}@${version}/${path}`,
    'unpkg': (packageName, version, path) => `https://unpkg.com/${packageName}@${version}/${path}`,
};
export const CDNS = [
    'jsdelivr',
    'unpkg',
];
export const getLoadModelErrorMessage = (modelPath, packageInformation, errs) => new Error([
    `Could not resolve URL ${modelPath} for package ${packageInformation.name}@${packageInformation.version}`,
    `Errors include:`,
    ...errs.map(([cdn, err,]) => `- ${cdn}: ${err.message}`),
].join('\n'));
export const fetchModel = async ({ path: modelPath, modelType, packageInformation, }) => {
    if (packageInformation) {
        const errs = [];
        for (let i = 0; i < CDNS.length; i++) {
            const cdn = CDNS[i];
            const getCDNFn = CDN_PATH_DEFINITIONS[cdn];
            try {
                const url = getCDNFn(packageInformation.name, packageInformation.version, modelPath);
                return await loadTfModel(url, modelType);
            }
            catch (err) {
                errs.push([cdn, err instanceof Error ? err : new Error(`There was an unknown error: ${JSON.stringify(err)}`),]);
            }
        }
        throw getLoadModelErrorMessage(modelPath, packageInformation, errs);
    }
    return await loadTfModel(modelPath, modelType);
};
export const loadModel = async (modelDefinition) => {
    try {
        isValidModelDefinition(modelDefinition);
    }
    catch (err) {
        throw err instanceof ModelDefinitionValidationError ? getModelDefinitionError(err.type, modelDefinition) : new Error(ERROR_MODEL_DEFINITION_BUG);
    }
    const model = await fetchModel(modelDefinition);
    return {
        model,
        modelDefinition,
    };
};
