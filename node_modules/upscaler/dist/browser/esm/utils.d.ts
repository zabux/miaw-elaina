import { tf } from './dependencies.generated';
import type { Progress, SingleArgProgress, ResultFormat, MultiArgTensorProgress, UpscaleArgs } from './types';
import { Range, ModelDefinitionFn, ModelDefinition, ModelDefinitionObjectOrFn, Shape4D, ProcessFn, ModelType, MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE } from '@upscalerjs/core';
export declare class AbortError extends Error {
    message: string;
}
export declare const ERROR_MISSING_MODEL_DEFINITION_PATH: string;
export declare const ERROR_INVALID_MODEL_TYPE: (modelType: unknown) => string;
export declare const ERROR_MODEL_DEFINITION_BUG = "There is a bug with the upscaler code. Please report this.";
export declare const WARNING_INPUT_SIZE_AND_PATCH_SIZE: string;
export declare const ERROR_WITH_MODEL_INPUT_SHAPE: (inputShape?: unknown) => string;
export declare function getModelDefinitionError(error: MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE, modelDefinition?: ModelDefinition): Error;
export declare const warn: (msg: string | string[]) => void;
export declare function isProgress(p: undefined | Progress): p is Progress;
export declare function isSingleArgProgress(p: Progress): p is SingleArgProgress;
export declare const isMultiArgTensorProgress: (p: Progress, output: ResultFormat, progressOutput: ResultFormat) => p is MultiArgTensorProgress;
export declare const isAborted: (abortSignal?: AbortSignal) => boolean;
declare type PostNext<T = unknown> = ((value: T) => (void | Promise<void>));
export declare function wrapGenerator<T = unknown, TReturn = any, TNext = unknown>(gen: Generator<T, TReturn, TNext> | AsyncGenerator<T, TReturn, TNext>, postNext?: PostNext<T>): Promise<TReturn>;
export declare function isModelDefinitionFn(modelDefinition: ModelDefinitionObjectOrFn): modelDefinition is ModelDefinitionFn;
export declare const tensorAsClampedArray: (tensor: tf.Tensor3D) => Uint8Array | Float32Array | Int32Array;
export declare function getModel(modelDefinition: ModelDefinitionObjectOrFn): ModelDefinition;
export declare function processAndDisposeOfTensor<T extends tf.Tensor>(tensor: T, ..._processFns: (ProcessFn<T> | undefined)[]): T;
export declare function loadTfModel(modelPath: string, modelType?: ModelType): Promise<tf.LayersModel | tf.GraphModel<string | tf.io.IOHandler>>;
export declare const getInputShape: (model: tf.GraphModel | tf.LayersModel) => Shape4D;
export declare const scaleIncomingPixels: (range?: Range) => (tensor: tf.Tensor4D) => tf.Tensor4D;
export declare const parsePatchAndInputSizes: (model: tf.LayersModel | tf.GraphModel, { patchSize, padding, }: UpscaleArgs) => Pick<UpscaleArgs, 'patchSize' | 'padding'>;
export declare const padInput: (inputShape?: Shape4D) => (pixels: tf.Tensor4D) => tf.Tensor4D;
export declare const trimInput: (imageSize: Shape4D, scale: number) => (pixels: tf.Tensor4D) => tf.Tensor4D;
export declare const scaleOutput: (range?: Range) => (pixels: tf.Tensor4D) => tf.Tensor4D;
export {};
//# sourceMappingURL=utils.d.ts.map