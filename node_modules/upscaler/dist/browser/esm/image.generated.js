import { tf, } from './dependencies.generated';
import { tensorAsClampedArray, } from './utils';
import { isString, isFourDimensionalTensor, isThreeDimensionalTensor, isTensor, } from '@upscalerjs/core';
const ERROR_ENVIRONMENT_DISALLOWS_BASE64_URL = 'https://upscalerjs.com/documentation/troubleshooting#environment-disallows-base64';
const ERROR_ENVIRONMENT_DISALLOWS_STRING_INPUT_URL = 'https://upscalerjs.com/documentation/troubleshooting#environment-disallows-string-input';
export const getEnvironmentDisallowsStringInput = () => new Error([
    'Environment does not support a string URL as an input format.',
    `For more information, see ${ERROR_ENVIRONMENT_DISALLOWS_STRING_INPUT_URL}.`,
].join('\n'));
export const getEnvironmentDisallowsBase64 = () => new Error([
    'Environment does not support base64 as an output format.',
    `For more information, see ${ERROR_ENVIRONMENT_DISALLOWS_BASE64_URL}.`,
].join('\n'));
export const getInvalidTensorError = (input) => new Error([
    `Unsupported dimensions for incoming pixels: ${input.shape.length}.`,
    'Only 3 or 4 rank tensors are supported.',
].join('\n'));
export const getInvalidImageError = () => new Error([
    'Failed to load image',
].join(' '));
export const loadImage = (src) => new Promise((resolve, reject) => {
    const img = new Image();
    img.src = src;
    img.crossOrigin = 'anonymous';
    img.onload = () => resolve(img);
    img.onerror = () => reject(getInvalidImageError());
});
const fromPixels = (input) => tf.browser.fromPixelsAsync(input);
const getTensorFromInput = async (input) => {
    if (isTensor(input)) {
        return input;
    }
    if (isString(input)) {
        const imgHTMLElement = await loadImage(input);
        return fromPixels(imgHTMLElement);
    }
    return fromPixels(input);
};
export const getImageAsTensor = async (input) => {
    const tensor = await getTensorFromInput(input);
    if (isThreeDimensionalTensor(tensor)) {
        const expandedTensor = tensor.expandDims(0);
        tensor.dispose();
        return expandedTensor;
    }
    if (isFourDimensionalTensor(tensor)) {
        return tensor;
    }
    throw getInvalidTensorError(tensor);
};
export const isHTMLImageElement = (pixels) => {
    try {
        return pixels instanceof HTMLImageElement;
    }
    catch (err) {
        return false;
    }
};
export const tensorAsBase64 = (tensor) => {
    const arr = tensorAsClampedArray(tensor);
    const [height, width,] = tensor.shape;
    const imageData = new ImageData(width, height);
    imageData.data.set(arr);
    const canvas = document.createElement('canvas');
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext('2d');
    if (!ctx) {
        throw new Error('No context found');
    }
    ctx.putImageData(imageData, 0, 0);
    return canvas.toDataURL();
};
const checkIfValidEnvironment = (errFn) => {
    try {
        (new Image() && 'createElement' in document) === true;
    }
    catch (err) {
        throw errFn();
    }
};
export const checkValidEnvironment = (input, { output = 'base64', progressOutput, }) => {
    if (typeof input === 'string') {
        checkIfValidEnvironment(getEnvironmentDisallowsStringInput);
    }
    if (progressOutput === 'base64' || output === 'base64') {
        checkIfValidEnvironment(getEnvironmentDisallowsBase64);
    }
};
