import { tf } from './dependencies.generated';
import type { PrivateUpscaleArgs, ModelPackage, BASE64, TENSOR, YieldedIntermediaryValue } from './types';
import { Input } from './image.generated';
import { Shape4D } from '@upscalerjs/core';
import { GraphModel, LayersModel } from '@tensorflow/tfjs';
export declare const WARNING_UNDEFINED_PADDING: string;
export declare const WARNING_PROGRESS_WITHOUT_PATCH_SIZE: string;
export declare const ERROR_INVALID_TENSOR_PREDICTED: (tensor: tf.Tensor) => string;
export declare const ERROR_INVALID_MODEL_PREDICTION: string;
export declare const GET_INVALID_SHAPED_TENSOR: (tensor: tf.Tensor) => Error;
export declare const GET_UNDEFINED_TENSORS_ERROR: () => Error;
export declare const getWidthAndHeight: (tensor: tf.Tensor3D | tf.Tensor4D) => [number, number];
export declare const getRowsAndColumns: (pixels: tf.Tensor3D | tf.Tensor4D, patchSize: number) => {
    rows: number;
    columns: number;
};
export interface GetTensorDimensionsOpts {
    row: number;
    col: number;
    patchSize: number;
    height: number;
    width: number;
    padding?: number;
}
export declare const GET_TENSOR_DIMENSION_ERROR_ROW_IS_UNDEFINED: Error;
export declare const GET_TENSOR_DIMENSION_ERROR_COL_IS_UNDEFINED: Error;
export declare const GET_TENSOR_DIMENSION_ERROR_PATCH_SIZE_IS_UNDEFINED: Error;
export declare const GET_TENSOR_DIMENSION_ERROR_HEIGHT_IS_UNDEFINED: Error;
export declare const GET_TENSOR_DIMENSION_ERROR_WIDTH_IS_UNDEFINED: Error;
export declare const getTensorDimensions: ({ row, col, patchSize, height, width, padding, }: GetTensorDimensionsOpts) => {
    origin: [number, number];
    sliceOrigin: [number, number];
    size: [number, number];
    sliceSize: [number, number];
};
export declare function concatTensors<T extends tf.Tensor3D | tf.Tensor4D>(tensors: Array<T | undefined>, axis?: number): T;
export declare const getPercentageComplete: (row: number, col: number, columns: number, total: number) => number;
export declare const executeModel: (model: LayersModel | GraphModel, pixels: tf.Tensor4D) => tf.Tensor4D;
export declare function predict(pixels: tf.Tensor4D, { output, progress, patchSize: patchSize, padding, progressOutput, }: PrivateUpscaleArgs, { model, modelDefinition, }: ModelPackage, { imageSize, inputSize, }: {
    imageSize: Shape4D;
    inputSize?: Shape4D;
}): AsyncGenerator<YieldedIntermediaryValue, tf.Tensor3D>;
export declare const getCopyOfInput: (input: Input) => Input;
export declare function upscale(input: Input, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64;
}, modelPackage: ModelPackage): AsyncGenerator<YieldedIntermediaryValue, string>;
export declare function upscale(input: Input, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: TENSOR;
}, modelPackage: ModelPackage): AsyncGenerator<YieldedIntermediaryValue, tf.Tensor3D>;
export declare function upscale(input: Input, args: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64 | TENSOR;
}, modelPackage: ModelPackage): AsyncGenerator<YieldedIntermediaryValue, string | tf.Tensor3D>;
export declare function cancellableUpscale(input: Input, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: TENSOR;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}): Promise<tf.Tensor3D>;
export declare function cancellableUpscale(input: Input, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}): Promise<string>;
export declare function cancellableUpscale(input: Input, { signal, awaitNextFrame, ...args }: Omit<PrivateUpscaleArgs, 'output'> & {
    output: BASE64 | TENSOR;
}, internalArgs: ModelPackage & {
    signal: AbortSignal;
}): Promise<tf.Tensor3D | string>;
//# sourceMappingURL=upscale.d.ts.map