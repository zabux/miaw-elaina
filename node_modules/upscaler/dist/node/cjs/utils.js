"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.scaleOutput = exports.trimInput = exports.padInput = exports.parsePatchAndInputSizes = exports.scaleIncomingPixels = exports.getInputShape = exports.loadTfModel = exports.processAndDisposeOfTensor = exports.getModel = exports.tensorAsClampedArray = exports.isModelDefinitionFn = exports.wrapGenerator = exports.isAborted = exports.isMultiArgTensorProgress = exports.isSingleArgProgress = exports.isProgress = exports.warn = exports.getModelDefinitionError = exports.ERROR_WITH_MODEL_INPUT_SHAPE = exports.WARNING_INPUT_SIZE_AND_PATCH_SIZE = exports.ERROR_MODEL_DEFINITION_BUG = exports.ERROR_INVALID_MODEL_TYPE = exports.ERROR_MISSING_MODEL_DEFINITION_PATH = exports.AbortError = void 0;
var dependencies_generated_1 = require("./dependencies.generated");
var core_1 = require("@upscalerjs/core");
var isLayersModel_1 = require("./isLayersModel");
var AbortError = (function (_super) {
    __extends(AbortError, _super);
    function AbortError() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.message = 'The upscale request received an abort signal';
        return _this;
    }
    return AbortError;
}(Error));
exports.AbortError = AbortError;
var ERROR_MISSING_MODEL_DEFINITION_PATH_URL = 'https://upscalerjs.com/documentation/troubleshooting#missing-model-path';
var ERROR_INVALID_MODEL_TYPE_URL = 'https://upscalerjs.com/documentation/troubleshooting#invalid-model-type';
var WARNING_INPUT_SIZE_AND_PATCH_SIZE_URL = 'https://upscalerjs.com/documentation/troubleshooting#input-size-and-patch-size';
var ERROR_WITH_MODEL_INPUT_SHAPE_URL = 'https://upscalerjs.com/documentation/troubleshooting#error-with-model-input-shape';
exports.ERROR_MISSING_MODEL_DEFINITION_PATH = [
    'You must provide a "path" when providing a model definition',
    "For more information, see ".concat(ERROR_MISSING_MODEL_DEFINITION_PATH_URL, "."),
].join('\n');
var ERROR_INVALID_MODEL_TYPE = function (modelType) { return ([
    "You've provided an invalid model type: ".concat(JSON.stringify(modelType), ". Accepted types are \"layers\" and \"graph\"."),
    "For more information, see ".concat(ERROR_INVALID_MODEL_TYPE_URL, "."),
].join('\n')); };
exports.ERROR_INVALID_MODEL_TYPE = ERROR_INVALID_MODEL_TYPE;
exports.ERROR_MODEL_DEFINITION_BUG = 'There is a bug with the upscaler code. Please report this.';
exports.WARNING_INPUT_SIZE_AND_PATCH_SIZE = [
    'You have provided a patchSize, but the model definition already includes an input size.',
    'Your patchSize will be ignored.',
    "For more information, see ".concat(WARNING_INPUT_SIZE_AND_PATCH_SIZE_URL, "."),
].join('\n');
var ERROR_WITH_MODEL_INPUT_SHAPE = function (inputShape) { return [
    "Expected model to have a rank-4 compatible input shape. Instead got: ".concat(JSON.stringify(inputShape), "."),
    "For more information, see ".concat(ERROR_WITH_MODEL_INPUT_SHAPE_URL, "."),
].join('\n'); };
exports.ERROR_WITH_MODEL_INPUT_SHAPE = ERROR_WITH_MODEL_INPUT_SHAPE;
function getModelDefinitionError(error, modelDefinition) {
    switch (error) {
        case core_1.MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE.MISSING_PATH:
            return new Error(exports.ERROR_MISSING_MODEL_DEFINITION_PATH);
        case core_1.MODEL_DEFINITION_VALIDATION_CHECK_ERROR_TYPE.INVALID_MODEL_TYPE:
            return new Error((0, exports.ERROR_INVALID_MODEL_TYPE)(modelDefinition === null || modelDefinition === void 0 ? void 0 : modelDefinition.modelType));
        default:
            return new Error(exports.ERROR_MODEL_DEFINITION_BUG);
    }
}
exports.getModelDefinitionError = getModelDefinitionError;
var warn = function (msg) {
    console.warn(Array.isArray(msg) ? msg.join('\n') : msg);
};
exports.warn = warn;
function isProgress(p) { return p !== undefined && typeof p === 'function'; }
exports.isProgress = isProgress;
function isSingleArgProgress(p) { return isProgress(p) && p.length <= 1; }
exports.isSingleArgProgress = isSingleArgProgress;
var isMultiArgTensorProgress = function (p, output, progressOutput) {
    if (!isProgress(p) || p.length <= 1) {
        return false;
    }
    return progressOutput === undefined && output === 'tensor' || progressOutput === 'tensor';
};
exports.isMultiArgTensorProgress = isMultiArgTensorProgress;
var isAborted = function (abortSignal) {
    if (abortSignal) {
        return abortSignal.aborted;
    }
    return false;
};
exports.isAborted = isAborted;
function wrapGenerator(gen, postNext) {
    return __awaiter(this, void 0, void 0, function () {
        var result;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4, gen.next()];
                case 1:
                    result = _a.sent();
                    _a.label = 2;
                case 2:
                    if (!!result.done) return [3, 6];
                    if (!postNext) return [3, 4];
                    return [4, postNext(result.value)];
                case 3:
                    _a.sent();
                    _a.label = 4;
                case 4: return [4, gen.next()];
                case 5:
                    result = _a.sent();
                    return [3, 2];
                case 6: return [2, result.value];
            }
        });
    });
}
exports.wrapGenerator = wrapGenerator;
function isModelDefinitionFn(modelDefinition) { return typeof modelDefinition === 'function'; }
exports.isModelDefinitionFn = isModelDefinitionFn;
var tensorAsClampedArray = function (tensor) { return dependencies_generated_1.tf.tidy(function () {
    var _a = tensor.shape, height = _a[0], width = _a[1];
    var fill = dependencies_generated_1.tf.fill([height, width,], 255).expandDims(2);
    return tensor.clipByValue(0, 255).concat([fill,], 2).dataSync();
}); };
exports.tensorAsClampedArray = tensorAsClampedArray;
function getModel(modelDefinition) {
    return isModelDefinitionFn(modelDefinition) ? modelDefinition(dependencies_generated_1.tf) : modelDefinition;
}
exports.getModel = getModel;
function nonNullable(value) {
    return value !== null && value !== undefined;
}
function processAndDisposeOfTensor(tensor) {
    var _processFns = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        _processFns[_i - 1] = arguments[_i];
    }
    var processFns = _processFns.filter(nonNullable);
    if (processFns.length) {
        var processedTensor = dependencies_generated_1.tf.tidy(function () { return processFns.reduce(function (reducedTensor, processFn) { return processFn(reducedTensor); }, tensor); });
        if (!tensor.isDisposed && tensor !== processedTensor) {
            tensor.dispose();
        }
        return processedTensor;
    }
    return tensor;
}
exports.processAndDisposeOfTensor = processAndDisposeOfTensor;
function loadTfModel(modelPath, modelType) {
    if (modelType === void 0) { modelType = 'layers'; }
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!(modelType === 'graph')) return [3, 2];
                    return [4, dependencies_generated_1.tf.loadGraphModel(modelPath)];
                case 1: return [2, _a.sent()];
                case 2: return [4, dependencies_generated_1.tf.loadLayersModel(modelPath)];
                case 3: return [2, _a.sent()];
            }
        });
    });
}
exports.loadTfModel = loadTfModel;
var getBatchInputShape = function (model) {
    if ((0, isLayersModel_1.isLayersModel)(model)) {
        return model.layers[0].batchInputShape;
    }
    return model.inputs[0].shape;
};
var getInputShape = function (model) {
    var batchInputShape = getBatchInputShape(model);
    if ((0, core_1.isShape4D)(batchInputShape)) {
        return batchInputShape;
    }
    throw new Error((0, exports.ERROR_WITH_MODEL_INPUT_SHAPE)(batchInputShape));
};
exports.getInputShape = getInputShape;
var scaleIncomingPixels = function (range) { return function (tensor) {
    if ((0, core_1.isValidRange)(range) && range[1] === 1) {
        return dependencies_generated_1.tf.mul(tensor, 1 / 255);
    }
    return tensor;
}; };
exports.scaleIncomingPixels = scaleIncomingPixels;
var isInputSizeDefined = function (inputShape) { return Boolean(inputShape) && (0, core_1.isShape4D)(inputShape) && Boolean(inputShape[1]) && Boolean(inputShape[2]); };
var parsePatchAndInputSizes = function (model, _a) {
    var patchSize = _a.patchSize, padding = _a.padding;
    var inputShape = (0, exports.getInputShape)(model);
    if (isInputSizeDefined(inputShape) && patchSize !== undefined) {
        (0, exports.warn)(exports.WARNING_INPUT_SIZE_AND_PATCH_SIZE);
    }
    if (isInputSizeDefined(inputShape)) {
        if (inputShape[1] !== inputShape[2]) {
            throw new Error('Input shape must be square');
        }
        return {
            patchSize: inputShape[1] - (padding || 0) * 2,
            padding: padding,
        };
    }
    return {
        patchSize: patchSize,
        padding: padding,
    };
};
exports.parsePatchAndInputSizes = parsePatchAndInputSizes;
var padInput = function (inputShape) { return function (pixels) {
    var pixelsHeight = pixels.shape[1];
    var pixelsWidth = pixels.shape[2];
    if (isInputSizeDefined(inputShape) && (inputShape[1] > pixelsHeight || inputShape[2] > pixelsWidth)) {
        return dependencies_generated_1.tf.tidy(function () {
            var height = Math.max(pixelsHeight, inputShape[1]);
            var width = Math.max(pixelsWidth, inputShape[2]);
            var rightTensor = dependencies_generated_1.tf.zeros([1, pixelsHeight, width - pixelsWidth, 3,]);
            var bottomTensor = dependencies_generated_1.tf.zeros([1, height - pixelsHeight, width, 3,]);
            var topTensor = dependencies_generated_1.tf.concat([pixels, rightTensor,], 2);
            var final = dependencies_generated_1.tf.concat([topTensor, bottomTensor,], 1);
            return final;
        });
    }
    return pixels;
}; };
exports.padInput = padInput;
var trimInput = function (imageSize, scale) { return function (pixels) {
    var height = imageSize[1] * scale;
    var width = imageSize[2] * scale;
    if (height < pixels.shape[1] || width < pixels.shape[2]) {
        return dependencies_generated_1.tf.tidy(function () { return dependencies_generated_1.tf.slice(pixels, [0, 0, 0,], [1, height, width, 3,]); });
    }
    return pixels;
}; };
exports.trimInput = trimInput;
var scaleOutput = function (range) { return function (pixels) {
    var endingRange = (0, core_1.isValidRange)(range) ? range[1] : 255;
    return pixels.clipByValue(0, endingRange).mul(endingRange === 1 ? 255 : 1);
}; };
exports.scaleOutput = scaleOutput;
